### 闭包作用域

**闭包的两大作用：1.保护（私有变量个外界没有必然联系）； 2.保存（形成不销毁的栈内存，里面的私有变量等信息都被保存下来了）**

1. 创建函数

   - 开辟一个堆内存，把函数体中的代码当作字符串存储进去
   - 把对内存的地址赋值给函数名/变量名
   - **函数在哪创建的，那么它执行时所需要查找的上级作用域就是谁，与它在哪执行无关**

2. 函数执行

   - 形成一个全新的私有作用域（执行依次形成一个，多个之间不会相互影响）
   - 形参赋值 & 变量提升
   - 代码执行（把所属堆内存中的代码字符串进行执行）
   - **遇到一个变量，首先看它是否为私有变量（形参和在私有作用域中声明的变量都是私有变量），是私有的就操作自己的变量，不是私有的则向上一级作用域中查找，直到找到全局作用域为止，这就是作用域链的查找机制**
   - 私有变量和外界的变量没有必然的关系，可以理解为被私有栈内保护起来了，这种机制就是**闭包的保护机制**

3. 关于堆栈内存释放为题（以谷歌webkit内核为例）

   > 函数执行就会形成栈内存（从内存中分配一块空间），如果内存都不销毁，很容易导致栈内存溢出-

   - 堆内存释放

   ```javascript
   // 创建一个引用类型值，就会产生一个堆内存。
   // 1. 如果当前创建的堆内存不被其它东西占用，浏览器会在空闲的时候，查找每一个内存的引用状况，不被占用都会被回收释放。
   var obj = {
       name:'zs'
   };
   var oo = obj;
   // 此时obj和oo都占用着对象的堆内存，想要释放堆内存，需要手动解除变量和值的关系（null：空对象指针）
   obj = null;
   oo = null;
   ```

   - 栈内存释放

   ```javascript
   // 1. 打开浏览器形成的全局作用域是栈内存
   // 2. 手动执行函数形成的私有作用域是栈内存
   // 3. 基于ES6中的let/const形成的块作用域也是栈内存
   
   /*
   全局栈内存：关掉页面时才会被销毁
   私有栈内存：1. 一般情况下，函数只要执行完成，形成的私有栈内存就会被销毁（排除死递归的模式）
   		  2. 但是一旦栈内存中某个东西（一般都是堆地址）被私有作用域以外的东西给占用了，则当前栈				内存不能立即被销毁（特点：私有作用域中的私有变量等信息也被保留下来了）
   */
   function fn(){}
   fn();	// 函数执行时形成栈内存，执行完成栈内存销毁
   
   function foo(){
       return function(){
           //..
       }
   }
   var bar = foo();	// bar占用了foo执行时形成的栈内存的一个东西（返回小函数对应的堆地址），则foo执行形成的栈内存不能被释放
   
   ```

   