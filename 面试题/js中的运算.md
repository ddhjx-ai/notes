### 1. ==运算

```shell
1.对象==字符串，对象转换为字符串（调用的是对象的valueOf和toString方法，可以通过重写该方法，将对象转换为自己想要的字符串，否则对象转换为字符串只会是"[object Object]"）。
2.null == undefind成立，null和undefined不在==任何值。
3.NaN和任何值都不==，包括它本身。
4.剩下的情况，都是转换为数字再进行==比较。
```

### 2. []==false 和 ![]==false

```js
[]==false // true
/*
[]和false都隐式转换为数字类型
[]转换为数字类型：先调用toString()方法，得到"",Number("") = 0;
false 转化为数字类型为0，所有两者比较结果为true
*/

![] == false // true
/*
先运算![]的结果为 false，然后false == false成立，结果为true。	
*/
```

### 3.  {} + 0 和 0 + {}

```javascript
{} + 0 // 0，{a:11} + 0 = 0
/*
js运行时将 {} 当做一个独立的代码块进行运行了，而不是一个对象，而{}代码块中没有任何可运行的语句，所以该题相当于 +0，所以结果为 0。
另：{}出现在运算符开始，都会被当做一个独立的代码块，而不进行运算。
	如果想将其进行运算，则可以用()，使其为一个整体的运算式。
*/

0 + {} //"0[object Object]"
/*
{}被当做一个对象执行，对象进行+运算时，会调用自身的toString()方法，得到"[object Object]"，然后字符串和0进行拼接，得到结果"0[object Object]"
*/

{}+0+{}
/*
这个运算结果在不同的浏览器下有不同的结果，chrome浏览器下为"[object Object]0[object Object]"
火狐浏览器的则为："0[object Object]"
*/
```

### 4.所有的赋值操作

```javascript
/*
1.创建值
	基本类型值时直接存储在栈内存中；
	引用类型值存在堆内存中，然后把堆内存的16进制地址放到栈中供变量引用。
2.创建变量
3.变量和值指针关联
*/

var a = {n:1};
a.x = a = {m:2};
/*
会先执行a.x = {m:2},然后再执行 a={m:2},
所有此时 a={m:2}
*/
```

