# 正则表达式

#### 1.判断正确网址

```javascript
let reg = /^(?:(http|https|ftp):\/\/)?((?:[\w-]+\.)+[a-z0-9]+)((?:\/[^/?#]*)+)?(\?[^#]+)?(#.+)$/i;
```

分析：

1. 协议名：//  +	http|https|ftp
2. 域名：www.4399.com|baidu.com|kbs.sports.qq.com.cn|kbs.sports.qq.com
3. 请求路径：/ | /index.html  |  /stu/index.html   |  /stu/
4. 问号传参：?xxx=xxx&xxx=xxx
5. 哈希值：#xxx

**知识点：**

1. 在正则表达式中，每个 () 表示一个分组，用 exec() 进行匹配时会返回一个数组，并且每一个分组都会匹配为数组中的每一项。 
2. 如果使用 ?:  (?:  () ) 就会只匹配不捕获

#### 2.验证密码， 6-16位字符串，必须同时包含大小写字母和数字

```javascript
let reg = /(?!^[a-zA-Z]$)(?!^[a-z0-9]$)(?![A-Z0-9]$)^[a-zA-Z0-9]{6,16}$/;
// 不能是纯字母，不能是小写字母和数字，也不能是大写字母和数字

// 1-10位：数字、字母、下划线组成的字符串，但是必须有下划线
var reg = /(?!^[a-zA-Z0-9]+$)^\w{1,10}$/

// 同时必须包含数字和字母
let reg = /^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z]{8}$/
```

**知识点：正向预查和负向预查**

1. (?=pattern)正向预查：要匹配的字符串必须满足 pattern 这个条件。

   需要注意：括号中的内容只是条件，并不参与真正的捕获，只是检查后面的字符是否符合要求而已

```javascript
var reg = /hello(?=8)/;
var str = 'hello9';
console.log(reg.exec(str));	// 返回 null
var str1 = 'hello8';
console.log(reg.exec(str1))	// 只会匹配到 hello
```

2. (?!pattern)负向预查：要求匹配的时候，必须不满足pattern这个条件

```javascript
var reg = /world(?!js)/;
var str = 'worldjs';
console.log(reg.exec(str));	// 返回 null
var str1 = 'worldabc';
console.log(reg.exec(str));	// 返回 world
```

**注意：**设置的条件不会参与 匹配和捕获，只是当作匹配时的条件

#### 3.千分符

```javascript
// 逻辑一：匹配以1-3位数字开头，后面必须是 多次出现的 3个连续的数字
	var str = '1234567890';// 1,234,567,890
	var reg = /^(\d{1,3})((\d{3})+)$/;
	var newStr = str.replace(reg,function(i){
	    // arguments 返回 ["123456789", "123", "456789", "789", 0, "123456789"] 
	    var res1 = arguments[1];
	    var res2 = arguments[2]
	    // 利用 ?! 负向预查，只捕获不匹配末尾的 逗号
	    return res1+','+res2.replace(/\d{3}(?!$)/g,function(){
	    	console.log(arguments)
	    	return arguments[0] + ','
	    })
	})
	console.log(newStr)

	// 逻辑二：如果 (字符串长度-当前字符的索引-1) % 3 == 0,则说明后面的字符串长度是3的整数倍，则当前字符后面可以添加一个千分符,
	var str = '492830581729';
	var reg = /\d(?!$)/g;	// (?!$)：表示不给最后一个字符添加千分符
	// 参数：item:匹配的到当前字符；	index：当前字符的索引
	var newStr = str.replace(reg,function(item,index){
		if((str.length-index-1)%3 === 0){
			return item+','
		}else {
			return item
		}
	})
	console.log(newStr)

	// 逻辑三：将字符串反转，然后每隔三个字符添加一个千分符，末尾不用添加，将得到的字符串反转为原字符串
	var str = '492830581729';
	str = str.split('').reverse().join('')
	str = str.replace(/(\d{3}(?!$))/g,"$1,")
	str = str.split('').reverse().join('')
	console.log(str)
```

#### 4.匹配0-9999

```javascript
/^(\d|[1-9]\d{1,3})$/
```



### 正则表达式的规则

#### 特殊字符：

| $    | 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\n' 或 '\r'。要匹配 $ 字符本身，请使用 \$。 |
| ---- | ------------------------------------------------------------ |
| ( )  | 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \( 和 \)。 |
| *    | 匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 \*。     |
| +    | 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \+。     |
| .    | 匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 \. 。    |
| [    | 标记一个中括号表达式的开始。要匹配 [，请使用 \[。            |
| ?    | 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。 |
| \    | 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， 'n' 匹配字符 'n'。'\n' 匹配换行符。序列 '\\' 匹配 "\"，而 '\(' 则匹配 "("。 |
| ^    | 匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 \^。 |
| {    | 标记限定符表达式的开始。要匹配 {，请使用 \{。                |
| \|   | 指明两项之间的一个选择。要匹配 \|，请使用 \|。               |

#### 限定符：

限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。

| *     | 匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。 |
| ----- | ------------------------------------------------------------ |
| +     | 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。 |
| ?     | 匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 、 "does" 中的 "does" 、 "doxy" 中的 "do" 。? 等价于 {0,1}。 |
| {n}   | n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。 |
| {n,}  | n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。 |
| {n,m} | m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。 |

**注意：**

1. *和+限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。

#### 定位符

定位符使您能够将正则表达式固定到行首或行尾。

| ^    | 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。 |
| ---- | ------------------------------------------------------------ |
| $    | 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。 |
| \b   | 匹配一个单词边界，即字与空格间的位置。                       |
| \B   | 非单词边界匹配。                                             |

**注意**：不能将限定符与定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许诸如 ^* 之类的表达式。

#### 确定重复出现

| 字符簇           | 描述                            |
| ---------------- | ------------------------------- |
| ^[a-zA-Z_]$      | 所有的字母和下划线              |
| ^[[:alpha:]]{3}$ | 所有的3个字母的单词             |
| ^a$              | 字母a                           |
| ^a{4}$           | aaaa                            |
| ^a{2,4}$         | aa,aaa或aaaa                    |
| ^a{1,3}$         | a,aa或aaa                       |
| ^a{2,}$          | 包含多于两个a的字符串           |
| ^a{2,}           | 如：aardvark和aaab，但apple不行 |
| a{2,}            | 如：baad和aaa，但Nantucket不行  |
| \t{2}            | 两个制表符                      |
| .{2}             | 所有的两个字符                  |

#### 方括号

 方括号用于查找某个范围内的字符： 

| 表达式             | 描述                               |
| ------------------ | ---------------------------------- |
| [abc\]             | 查找方括号之间的任何字符。         |
| [^abc\]            | 查找任何不在方括号之间的字符。     |
| [0-9]              | 查找任何从 0 至 9 的数字。         |
| [a-z]              | 查找任何从小写 a 到小写 z 的字符。 |
| [A-Z]              | 查找任何从大写 A 到大写 Z 的字符。 |
| [A-z]              | 查找任何从大写 A 到小写 z 的字符。 |
| [adgk]             | 查找给定集合内的任何字符。         |
| [^adgk]            | 查找给定集合外的任何字符。         |
| (red\|blue\|green) | 查找任何指定的选项。               |

#### 元字符

 元字符（Metacharacter）是拥有特殊含义的字符： 

| 元字符 | 描述                                        |
| ------ | ------------------------------------------- |
| .      | 查找单个字符，除了换行和行结束符。          |
| \w     | 查找单词字符。                              |
| \W     | 查找非单词字符。                            |
| \d     | 查找数字。                                  |
| \D     | 查找非数字字符。                            |
| \s     | 查找空白字符。                              |
| \S     | 查找非空白字符。                            |
| \b     | 匹配单词边界。                              |
| \B     | 匹配非单词边界。                            |
| \0     | 查找 NULL 字符。                            |
| \n     | 查找换行符。                                |
| \f     | 查找换页符。                                |
| \r     | 查找回车符。                                |
| \t     | 查找制表符。                                |
| \v     | 查找垂直制表符。                            |
| \xxx   | 查找以八进制数 xxx 规定的字符。             |
| \xdd   | 查找以十六进制数 dd 规定的字符。            |
| \uxxxx | 查找以十六进制数 xxxx 规定的 Unicode 字符。 |

#### RegExp 对象方法

| 方法     | 描述                                               |
| -------- | -------------------------------------------------- |
| compile  | 在 1.5 版本中已废弃。 编译正则表达式。             |
| exec     | 检索字符串中指定的值。返回找到的值，并确定其位置。 |
| test     | 检索字符串中指定的值。返回 true 或 false。         |
| toString | 返回正则表达式的字符串。                           |

#### 支持正则表达式的 String 对象的方法

| 方法    | 描述                             | FF   | IE   |
| ------- | -------------------------------- | ---- | ---- |
| search  | 检索与正则表达式相匹配的值。     | 1    | 4    |
| match   | 找到一个或多个正则表达式的匹配。 | 1    | 4    |
| replace | 替换与正则表达式匹配的子串。     | 1    | 4    |
| split   | 把字符串分割为字符串数组。       | 1    | 4    |

#### RegExp 对象属性 

| 属性        | 描述                                               |
| ----------- | -------------------------------------------------- |
| constructor | 返回一个函数，该函数是一个创建 RegExp 对象的原型。 |
| global      | 判断是否设置了 "g" 修饰符                          |
| ignoreCase  | 判断是否设置了 "i" 修饰符                          |
| lastIndex   | 用于规定下次匹配的起始位置                         |
| multiline   | 判断是否设置了 "m" 修饰符                          |
| source      | 返回正则表达式的匹配模式                           |

**注意：**

一个数字 {x} 的意思是**前面的字符或字符簇只出现x次** ；一个数字加逗号 {x,} 的意思是**前面的内容出现x或更多的次数** ；两个数字用逗号分隔的数字 {x,y} 表示 **前面的内容至少出现x次，但不超过y次**。

```javascript
^[a-zA-Z0-9_]+$      // 所有包含一个以上的字母、数字或下划线的字符串 
^[1-9][0-9]*$        // 所有的正整数 
^\-?[0-9]+$          // 所有的整数 
^[-]?[0-9]+(\.[0-9]+)?$ // 所有的浮点数
```

#### new RegExp（）

当使用构造函数创造正则对象时，需要常规的字符转义规则（在前面加反斜杠 \）;

使用构造函数创建正则表达式，可以传入变量，使用字面量创建的正则表达式无法识别传入的变量

```javascript
var re = new RegExp('\\w+','g');
// 等同于：
var re = /\w+/g;
```

#### RegExp.prototype.exec()

**exec()** 方法在一个指定字符串中执行一个搜索匹配。返回一个结果数组或 [`null`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null)。
 **语法:**``regexObj.exec(str)``

```javascript
var regex = RegExp('foo*','g');
var str = 'table football, foosball';
var arr = regex.exec(str);
console.log(arr)// 返回 ['foo']
```

#### RegExp  对象中的 ()

在正则表达式中，提供一个再次检索的功能，是将想要再次检索的内容用 () 包起来

```javascript
var str = '我是{{name}}';
var reg = /{{(\w+)}}/;
console.log(reg.exec(str));	// 返回 ['{{name}}','name'];
```

#### 创建正则的两种方式

```javascript
// 1.构造函数因为传递的是字符串，\ 需要写两个才能代表单斜杠
var reg = /\d+/g;
// \d 元字符在构造函数创建的正则中，需要\ 作为转义符
var reg = new RegExp('\\d+','g');

// 2. 如果正则中要包含某个变量，只能使用构造函数方式创建;字面量形式创建的正则表达式中只能是元字符
var str = 'test'
var reg = new RegExp(str)
```

### 正则捕获的方法

> - 正则RegExp.prototype上的方法
>   - exec
>   - test
> - 字符串String.prototype上的方法
>   - replace
>   - match
>   - split
>   - search

#### 正则捕获的懒惰性

```javascript
var str = 'hello 1993 world 2003 i can 2013';
var reg = /\d+/;
console.log(reg.exec(str));
// ["1993", index: 6, input: "hello 1993 world 2003 i can 2013", groups: undefined]
/*
	exec正则捕获：
	1.捕获的结果是null或者一个数组
		第一项：本次捕获的内容
		groups：对应小分组本次单独捕获的内容
		index：当前捕获内容在字符串中的起始索引
		input：原始字符串
	2.每次执行一次exec，只能捕获一个符合正则规则的结果，其余的捕获不到,即使是在全局捕获的条件下，也只会捕获一个符合规则的结果；这就是正则捕获的懒惰性
*/

console.log(reg.lastIndex);	// 0
/*
	reg.lastIndex：当前正则下一次匹配的起始索引位置；由于第一次捕获完成，lastIndex没有改变，所以下一次exec依然从字符串最开始位置进行匹配，匹配到的值永远都是第一个；
	
	懒惰性捕获的原因：由于默认情况下，lastIndex的值不会被修改，每一次都只会从字符串的起始位置查找。
	解决办法：全局修饰符 g
*/

reg = /\d+/g;
console.log(reg.exec(str));	// []
console.log(reg.lastIndex);	// 17
console.log(reg.exec(str));	// []
console.log(reg.lastIndex);	// 21
/*
	当设置全局匹配修饰符g后，第一次匹配完，lastIndex会自动修改;
	当捕获完毕后，再次捕获的结果为null，但是lastIndex又回归为初始值0；同时可以再次开始捕获
*/
```

#### 自定义一个方法execAll(),执行一次可以将所有结果匹配到

```javascript
// 该正则一定要设置全局修饰符g
(function(){
    // str：要匹配的字符串
    function execAll(str=''){
        // 进来后首先要验证当前正则是否设置了g，不设置则不能进行循环捕获，否则会导致死循环
        if(!this.global) return this.exec(str);
        // 创建一个空数组，用来存储捕获的结果
        var arr = [];
        // this表示当前RegExp的实例
        var res = this.exec(str);
        while(res){
            // 把每次捕获的内容存放到数组中
            arr.push(res[0]);
            // 只要捕获的结果不为null，就一直捕获下去
            res = this.exec(str);
        }
        return arr.length===0 ? null : arr;
    }
    RegExp.prototype.execAll = execAll;
})()

// 使用 String.prototype.match() 方法也可得到上面函数匹配后的结果
```

#### 正则的分组捕获

```javascript
var str = '420115199311036633';
var reg = /^(\d{6})(\d{4})(\d{2})(\d{2})(\d{2})(\d)(?:\d|X)$/;
console.log(reg.exec(str));
console.log(str.match(reg));
// 都返回： ["420115199311036633", "420115", "1993", "11", "03", "66", "3", index: 0, input: "420115199311036633", groups: undefined]
// 第一项：大正则匹配的结果
// 其余项：每个小分组单独匹配捕获的结果
// 如果需要通过设置分组来改变优先级，但是捕获时不需要单独捕获，可以通过?:来实现
```

```javascript
// 既要捕获到{数字}，又要单独把数据也捕获到
var str = '{2019}年{9}月{28}号';
var reg = /\{(\d+)\}/;
// 不设置全局匹配的情况下，exec和match捕获的结果一样，既有大正则匹配的结果，又有小正则匹配的结果	["{2019}","2019",...]
console.log(reg.exec(str));
console.log(str.match(reg));

reg = /\{(\d+)\}/g;
console.log(str.match(reg)); // ["{2019}", "{9}", "{28}"]
// 全局匹配的情况下，match只能把大正则匹配的内容获取到，小分组匹配的信息无法获取到；所以还是需要类似前面的execAll的方法，获取全部的匹配信息
var arrBig = [],
    arrSmall = [],
    res = reg.exec(str);
while(res){
    // 通过数组结构，同时获取数组中数据
    var [big,small] = res;
    arrBig.push(big);
    arrSmall.push(small);
    res=reg.exec(str);
}
console.log(arrBig,arrSmall);// ["{2019}", "{9}", "{28}"] ["2019", "9", "28"]
```

##### 分组引用

```javascript
// 分组引用就是通过"\数字"，让分组中的内容出现重复出现指定的次数
var str = 'good';	// 'book','foot','moon'.....
var reg = /^[a-zA-Z]([a-zA-Z])\1[a-zA-Z]$/
```

#### 正则捕获的贪婪性

```javascript
// 正则捕获的贪婪性：默认情况下，正则捕获的时候，是按照当前正则所匹配的最长结果来获取的
var str = '2019nianzhi2020nian';
var reg = /\d+/g;
console.log(str.match(reg));	// ["2019", "2020"]

// 取消正则捕获的贪婪性:在两次元字符后面添加?	(就是按照正则匹配的最短结果来获取)
reg = /\d+?/g;
console.log(str.match(reg));	//["2", "0", "1", "9", "2", "0", "2", "0"]
```

##### ？在正则中的作用

1. 问号左边是非量词元字符：本身代表量词元字符，出现零次到一次
2. 问号左边是量词元字符：取消捕获时的贪婪性
3. (?:) 只匹配不捕获
4. (?=) 正向预查
5. (?!) 负向预查

#### 其他正则捕获的方法

**1.test捕获**

```javascript
var str = '{0}年{1}月{2}日';
var reg = /\{(\d+)\}/g;
console.log(reg.test(str)); // true
console.log(RegExp.$1); // 0

// RegExp.$1--RegExp.$9:获取当前本次正则匹配后，第一个到第九个分组的信息
```

