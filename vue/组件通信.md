#### 父传子

1. 属性props

```javascript
// child 
props:{msg:String}

// parent
<comp msg='test'>
```

2. 引用resfs

```javascript
// parent
<comp ref='comp'>
this.$refs.comp.xxx = 'xxx'
```

3. 子元素$children

> 官方：需要注意 $children并不保证子元素顺序，也不是响应式

```javascript
// parent
this.$children[0].xx = 'xxxx'
```

#### 子传父

```javascript
// child
this.$emit('add', 1)

// parent
<Cart @add='cartAdd($event)'>
```

#### 兄弟组件：通过共同祖辈组件 $parent或$root

```javascript
// brother1
this.$parent.$on('foo',handle)
// brother2
this.$parent.$emit('foo')
```

#### 祖先和后代之间

由于嵌套层数过多，传递props不切实际，vue提供了provide/inject API完成该任务

- provide/inject：能够实现祖先给后代传值

```javascript
// ancestor
// 这里可以写成对象的形式，类似data
provide() {
    return {foo: 'foo'}
}
// descendant
inject: ['foo']
```

> 注意：provide和inject主要为构建插件/组件库提供用例，并**不推荐直接应用于程序代码中**。
>
> 不建议修改传入的值，如果需要改，可以传入一个函数，通过函数去修改该值
>
> 但是，反过来想要后代给祖先传值这种方案就不行

#### 任意两个组件之间：事件总线或vuex

- 事件总线：创建一个Bus类负责事件派发、监听和回调管理

```javascript
// Bus:事件派发、监听和回调管理
class Bus{
    constructor(){
     	this.callbacks = {}   
    }
    
    $on(name, fn){
        this.callbacks[name] = this.callbacks[name] || []
        this.callbacks[name].push(fn)
    }
    $emit(name, args){
        if(this.callbacks[name]){
            this.callbacks[name].forEach(cn => cb(args))
        }
    }
}

// main.js
Vue.prototype.$bus = new Bus

// child1.vue
this.$bus.$on('foo', handle)

// child2.vue
this.$bus.$emit('foo')
```

